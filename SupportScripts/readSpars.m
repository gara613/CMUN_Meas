%% [Spars, freqs, R_car] = readSpars(varargin)
% Reads touchstone *.snp files (VNA lab compatibilidad, CST, QUCS, FSHview, etc),
% besides of the *.set files generated by the R&S VNA in the lab de física aplicada UN. 
% (The latter must be a *.txt file from the data copied using the software FHSview)
%
% Notes:    - Lacks an extension to read noise parameters in the *.snp files 
%           - Lacks validaion of inline comments (after the #freq.) in the *.snp files
%
% Format *.snp, please refer to the specification: Touchstone® File Format Specification    
% Header line: # <frequency unit> <parameter> <format> R <n>
% Frequency unit (G=GHz,M=MHz,etc), kind of parameters in file (S,Z,Y,etc), format (MA=Magnitud y Ángulo,RI=Real e Imaginario, DB=MA, etc), reference port impedance
% Comment lines begin with: '!'
%
% Applied physics lab analyzer (VNA R&S FSH8), uses a proprietary format: *.set:
% Exports S parameters in traces, it is necessary to define and employ a unified convention to export data! 
% Currently used for 4 traces: Tr1 = S11, Tr2 = S22, Tr3 = S21, Tr4 = S12
%_______________________________________________________________________________________________________________
%
% Inputs: (path, option)
%   - path to the file to be read 
%   - option = 's11' (literal string), only in the case of requiring the read a *.set file containing only the S11 parameter
% Outputs: [S, freq, Rcar]
%   - S parameters matrix (nports x nports x nfreqs), even for one port networs (1x1xnfreqs) 
%   - frequency vector (nfreqs x 1) 
%   - reference impedance in the measurements
%
% Universidad Nacional de Colombia
% Germán Augusto Ramírez Arroyave
% Grupo de Investigación en Telecomunicaciones - CMUN (2014)

function [Spars, freqs, R_car] = readSpars(varargin)

    narginchk(1,2);
    filename = char(varargin{1});
    if nargin == 2 % Option is currently used only to indicate that the *.set file to read contains an S11 measurement
        option = varargin{2};
    else
        option = false;
    end
    Spars = [];
    freqs = [];
    R_car = 50;     % Default values
    %% Open file (read only text mode) 
    fileId = fopen(filename, 'rt');                 % file in text mode
    parsedname = regexp(filename, '\.', 'split');   % separate file name and extension
    % cont=0;  %  to read Snp files with noise figures (e.g. for transistors)

    %% Reads s1p files 
    if strcmp(parsedname(end),'s1p')
        [unidadesfreq, formato, R_car] = headerSnp(fileId);

        datos = textscan(fileId, '%f %f %f');

        % Frequency vector (other units are not very interesting and are omitted)
        if unidadesfreq == 'T'
            freqs = datos{:,1}*1e12;
        elseif unidadesfreq == 'G'
            freqs = datos{:,1}*1e9;
        elseif unidadesfreq == 'M'
            freqs = datos{:,1}*1e6;
        elseif unidadesfreq == 'H'
            freqs = datos{:,1};
        end

        % Format Magnitude and Angle
        if strcmp(formato,'MA')
            Spars(1,1,:) = datos{:,2}.*exp(1i*datos{:,3}*pi/180);
        % Format Real and Imaginary
        elseif strcmp(formato,'RI')
            Spars(1,1,:) = complex(datos{:,2},datos{:,3});
        else
            error('Error in readSpars: loading file *.s1p - format not known');
        end

    %% Reads s2p files
    elseif strcmp(parsedname(end),'s2p')
        [unidadesfreq, formato, R_car] = headerSnp(fileId);

        datos = textscan(fileId, '%f %f %f %f %f %f %f %f %f');

        % Frequency vector 
        if unidadesfreq == 'T'
            freqs = datos{:,1}*1e12;
        elseif unidadesfreq == 'G'
            freqs = datos{:,1}*1e9;
        elseif unidadesfreq == 'M'
            freqs = datos{:,1}*1e6;
        elseif unidadesfreq == 'H'
            freqs = datos{:,1};
        end

        % Format Magnitude and Angle (DB as exported in the FHSview software)
        if strcmp(formato,'MA') || strcmp(formato,'DB') 
            Spars(1,1,:) = datos{:,2}.*exp(1i*datos{:,3}*pi/180);
            Spars(2,1,:) = datos{:,4}.*exp(1i*datos{:,5}*pi/180);
            Spars(1,2,:) = datos{:,6}.*exp(1i*datos{:,7}*pi/180);
            Spars(2,2,:) = datos{:,8}.*exp(1i*datos{:,9}*pi/180);
        % Format Real and Imaginary
        elseif strcmp(formato,'RI')
            Spars(1,1,:) = complex(datos{:,2},datos{:,3});
            Spars(2,1,:) = complex(datos{:,4},datos{:,5});
            Spars(1,2,:) = complex(datos{:,6},datos{:,7});
            Spars(2,2,:) = complex(datos{:,8},datos{:,9});
        else 
            error('Error in readSpars: loading .s2p file - format not known');
        end

    %% Reads s3p files (Not validated yet...)
    elseif strcmp(parsedname(end),'s3p')     
        disp('Warning en readSpars: cargado de archivos *.s3p - no se ha validado aún');
        [unidadesfreq, formato, R_car] = headerSnp(fileId);

        datos = textscan(fileId, '%f %f %f %f %f %f %f');
        % 3-port network description
        % <frequency value> <N11> <N12> <N13>
        %                   <N21> <N22> <N23>
        %                   <N31> <N32> <N33>

        % Frequency vector
        if unidadesfreq == 'T'
            freqs = datos{1:3:end,1}*1e12;
        elseif unidadesfreq == 'G'
            freqs = datos{1:3:end,1}*1e9;
        elseif unidadesfreq == 'M'
            freqs = datos{1:3:end,1}*1e6;
        elseif unidadesfreq == 'H'
            freqs = datos{:,1};
        end

        % Format Magnitude and Angle
        if strcmp(formato,'MA')
            Spars(1,1,:) = datos{1:3:end,2}.*exp(1i*datos{1:3:end,3}*pi/180);
            Spars(1,2,:) = datos{1:3:end,4}.*exp(1i*datos{1:3:end,5}*pi/180);
            Spars(1,3,:) = datos{1:3:end,6}.*exp(1i*datos{1:3:end,7}*pi/180);
            Spars(2,1,:) = datos{2:3:end,2}.*exp(1i*datos{2:3:end,3}*pi/180);
            Spars(2,2,:) = datos{2:3:end,4}.*exp(1i*datos{2:3:end,5}*pi/180);
            Spars(2,3,:) = datos{2:3:end,6}.*exp(1i*datos{2:3:end,7}*pi/180);
            Spars(3,1,:) = datos{3:3:end,2}.*exp(1i*datos{3:3:end,3}*pi/180);
            Spars(3,2,:) = datos{3:3:end,4}.*exp(1i*datos{3:3:end,5}*pi/180);
            Spars(3,3,:) = datos{3:3:end,6}.*exp(1i*datos{3:3:end,7}*pi/180);
        % Format Real and Imaginary
        elseif strcmp(formato,'RI')
            Spars(1,1,:) = complex(datos{1:3:end,2},datos{1:3:end,3}); 
            Spars(1,2,:) = complex(datos{1:3:end,4},datos{1:3:end,5});
            Spars(1,3,:) = complex(datos{1:3:end,6},datos{1:3:end,7});
            Spars(2,1,:) = complex(datos{2:3:end,2},datos{2:3:end,3});
            Spars(2,2,:) = complex(datos{2:3:end,4},datos{2:3:end,5});
            Spars(2,3,:) = complex(datos{2:3:end,6},datos{2:3:end,7});
            Spars(3,1,:) = complex(datos{3:3:end,2},datos{3:3:end,3});
            Spars(3,2,:) = complex(datos{3:3:end,4},datos{3:3:end,5});
            Spars(3,3,:) = complex(datos{3:3:end,6},datos{3:3:end,7});
        else 
            disp('Error in readSpars: loading .s3p file - format not known');
        end

    %% Lee archivos s4p (Pendiente validacíón...)
    elseif strcmp(parsedname(end),'s4p')     
        disp('Warning en readSpars: cargado de archivos *.s4p - no se ha validado aún');
        [unidadesfreq, formato, R_car] = headerSnp(fileId);

        datos = textscan(fileId, '%f %f %f %f %f %f %f %f %f');
        % 4-port network description
        % <frequency value> <N11> <N12> <N13> <N14>
        %                   <N21> <N22> <N23> <N24>
        %                   <N31> <N32> <N33> <N34>
        %                   <N41> <N42> <N43> <N44>  

        % Frequency vector
        if unidadesfreq == 'T'
            freqs = datos{1:4:end,1}*1e12;
        elseif unidadesfreq == 'G'
            freqs = datos{1:4:end,1}*1e9;
        elseif unidadesfreq == 'M'
            freqs = datos{1:4:end,1}*1e6;
        elseif unidadesfreq == 'H'
            freqs = datos{:,1};
        end

        % Format Magnitude and Angle
        if strcmp(formato,'MA')
            Spars(1,1,:) = datos{1:4:end,2}.*exp(1i*datos{1:4:end,3}*pi/180);
            Spars(1,2,:) = datos{1:4:end,4}.*exp(1i*datos{1:4:end,5}*pi/180);
            Spars(1,3,:) = datos{1:4:end,6}.*exp(1i*datos{1:4:end,7}*pi/180);
            Spars(1,4,:) = datos{1:4:end,8}.*exp(1i*datos{1:4:end,9}*pi/180);
            Spars(2,1,:) = datos{2:4:end,2}.*exp(1i*datos{2:4:end,3}*pi/180);
            Spars(2,2,:) = datos{2:4:end,4}.*exp(1i*datos{2:4:end,5}*pi/180);
            Spars(2,3,:) = datos{2:4:end,6}.*exp(1i*datos{2:4:end,7}*pi/180);
            Spars(2,4,:) = datos{2:4:end,8}.*exp(1i*datos{2:4:end,9}*pi/180);
            Spars(3,1,:) = datos{3:4:end,2}.*exp(1i*datos{3:4:end,3}*pi/180);
            Spars(3,2,:) = datos{3:4:end,4}.*exp(1i*datos{3:4:end,5}*pi/180);
            Spars(3,3,:) = datos{3:4:end,6}.*exp(1i*datos{3:4:end,7}*pi/180);
            Spars(3,4,:) = datos{3:4:end,8}.*exp(1i*datos{3:4:end,9}*pi/180);
            Spars(4,1,:) = datos{4:4:end,2}.*exp(1i*datos{4:4:end,3}*pi/180);
            Spars(4,2,:) = datos{4:4:end,4}.*exp(1i*datos{4:4:end,5}*pi/180);
            Spars(4,3,:) = datos{4:4:end,6}.*exp(1i*datos{4:4:end,7}*pi/180);
            Spars(4,4,:) = datos{4:4:end,8}.*exp(1i*datos{4:4:end,9}*pi/180);
        % Format Real and Imaginary
        elseif strcmp(formato,'RI')
            Spars(1,1,:) = complex(datos{1:4:end,2},datos{1:4:end,3});
            Spars(1,2,:) = complex(datos{1:4:end,4},datos{1:4:end,5});
            Spars(1,3,:) = complex(datos{1:4:end,6},datos{1:4:end,7});
            Spars(1,4,:) = complex(datos{1:4:end,8},datos{1:4:end,9});
            Spars(2,1,:) = complex(datos{2:4:end,2},datos{2:4:end,3});
            Spars(2,2,:) = complex(datos{2:4:end,4},datos{2:4:end,5});
            Spars(2,3,:) = complex(datos{2:4:end,6},datos{2:4:end,7});
            Spars(2,4,:) = complex(datos{2:4:end,8},datos{2:4:end,9});
            Spars(3,1,:) = complex(datos{3:4:end,2},datos{3:4:end,3});
            Spars(3,2,:) = complex(datos{3:4:end,4},datos{3:4:end,5});
            Spars(3,3,:) = complex(datos{3:4:end,6},datos{3:4:end,7});
            Spars(3,4,:) = complex(datos{3:4:end,8},datos{3:4:end,9});
            Spars(4,1,:) = complex(datos{4:4:end,2},datos{4:4:end,3});
            Spars(4,2,:) = complex(datos{4:4:end,4},datos{4:4:end,5});
            Spars(4,3,:) = complex(datos{4:4:end,6},datos{4:4:end,7});
            Spars(4,4,:) = complex(datos{4:4:end,8},datos{4:4:end,9});
        else 
            disp('Error in readSpars: loading .s4p file - format not known');
        end

    %% Reads files in the R&S FSH8 VNA format (.txt file not .set )
    elseif strcmp(parsedname(end),'txt')	% data must be copied and saved as *.txt
        % in case commas are not replaced by dots in the source file
        fid = fopen(filename, 'r');
        Data = fscanf(fid,'%c');
        fclose(fid);                    
        Data = strrep(Data, ',', '.'); % don't know why matlab doesn't allow to overwrite the entire file
        fid = fopen(filename, 'w');   
        fprintf(fid, Data, '%c');
        fclose(fid);

        while feof(fileId) == 0
            linea_actual = fgets(fileId);   
            if ~isempty(linea_actual) & length(linea_actual) > 1
                if strcmp(linea_actual(1:5), 'Freq.'); % Find header line
                    break
                end
            end
        end
        % R_car = search the line that begins with: RF Input and get the number... not done yet
        % In case just S11 is of interest
        if strcmp(option,'s11')
            %extracts all the data from the 3 columns in trace 1... (columns 4, 5 y 6 are repeated information)
            datos = textscan(fileId, '%f %f %f %f %f %f');
            %frequency vector
            freqs = datos{:,1};
            %S parameters in the case of only S11 
            S11_mag_dB = datos{:,2};
            S11_Fase = datos{:,3};
            Spars(1,1,:) = 10.^(S11_mag_dB/20).*exp(1i*S11_Fase*pi/180); % return linear values as is the case for Snp files
        else % S pars of two port networks
            datos = textscan(fileId, '%f %f %f %f %f %f %f %f %f %f %f %f');
            %frequency vector
            freqs = datos{:,1};
            %Each trace contains: frequency, magnitude and phase in three columns
            %According to the convention: Tr1 = S11, Tr2 = S22, Tr3 = S21, Tr4 = S12
            S11_mag_dB = datos{:,2};
            S11_Fase = datos{:,3};
            S22_mag_dB = datos{:,5}; % Same frequency sampling is assumed for the 4 traces, hence columns 4,7,10 are omitted 
            S22_Fase = datos{:,6};
            S21_mag_dB = datos{:,8};
            S21_Fase = datos{:,9};
            S12_mag_dB = datos{:,11};
            S12_Fase = datos{:,12};

            Spars(1,1,:) = 10.^(S11_mag_dB/20).*exp(1i*S11_Fase*pi/180);  % return linear values
            Spars(1,2,:) = 10.^(S12_mag_dB/20).*exp(1i*S12_Fase*pi/180);  
            Spars(2,1,:) = 10.^(S21_mag_dB/20).*exp(1i*S21_Fase*pi/180);  
            Spars(2,2,:) = 10.^(S22_mag_dB/20).*exp(1i*S22_Fase*pi/180);  
        end
    end
    fclose(fileId);
end

% Touchstone files header's reading 
function [unidadesfreq, formato, R_car] = headerSnp(fileId)
    while feof(fileId) == 0
        linea_actual = fgets(fileId);
        if strcmp(linea_actual(1),'#');
            break
        end
    end
    inicios = regexp(linea_actual, '\s');       % reads the header, separator = space
    unidadesfreq = linea_actual(inicios(1)+1);  % frequency units
    parametro = linea_actual(inicios(2)+1);     % parameter kind
    if parametro ~= 'S' && parametro ~= 's'
        disp(['The supplid file contains: ', parametro, ' parameters']);
    end     
    formato = linea_actual(inicios(3)+1:inicios(3)+2);  % file format
    R_car = str2num(linea_actual(inicios(5):end));      % reference impedance
end